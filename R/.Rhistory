opened.doors <- open_goat_doors( this.game, my.initial.pick )
# save results for both strategies for the game
my.final.pick.stay <- change_door( stay=T, opened.doors=opened.doors, a.pick=my.initial.pick )
my.final.pick.switch <- change_door( stay=F, opened.doors=opened.doors, a.pick=my.initial.pick )
game.outcome.stay <- determine_winner( final.pick=my.final.pick.stay, game=this.game )
game.outcome.switch <- determine_winner( final.pick=my.final.pick.switch, game=this.game )
play_game <- function( )
{
doors             <- build_doors()
new.game          <- create_game()
first.pick        <- select_door()
opened.door       <- open_goat_doors( new.game, first.pick )
final.pick.stay   <- change_door( stay=T, opened.door, first.pick )
final.pick.switch <- change_door( stay=F, opened.door, first.pick )
outcome.stay      <- determine_winner( final.pick.stay, new.game  )
outcome.switch    <- determine_winner( final.pick.switch, new.game )
strategy     <- c( "stay", "switch" )
outcome      <- c( outcome.stay, outcome.switch )
game.results <- data.frame( strategy, outcome )
return( game.results )
}
x<-play_game() %>% pander()  # pander is for pretty printing
class(x)
play_game <- function( )
{
doors             <- build_doors()
new.game          <- create_game()
first.pick        <- select_door()
opened.door       <- open_goat_doors( new.game, first.pick )
final.pick.stay   <- change_door( stay=T, opened.door, first.pick )
final.pick.switch <- change_door( stay=F, opened.door, first.pick )
outcome.stay      <- determine_winner( final.pick.stay, new.game  )
outcome.switch    <- determine_winner( final.pick.switch, new.game )
strategy     <- c( "stay", "switch" )
outcome      <- c( outcome.stay, outcome.switch )
game.results <- data.frame( strategy, outcome )
return( game.results )
}
x<-play_game()  # pander is for pretty printing
class(x)
play_game <- function( )
{
doors             <- build_doors()
new.game          <- create_game()
first.pick        <- select_door()
opened.door       <- open_goat_doors( new.game, first.pick )
final.pick.stay   <- change_door( stay=T, opened.door, first.pick )
final.pick.switch <- change_door( stay=F, opened.door, first.pick )
outcome.stay      <- determine_winner( final.pick.stay, new.game  )
outcome.switch    <- determine_winner( final.pick.switch, new.game )
strategy     <- c( "stay", "switch" )
outcome      <- c( outcome.stay, outcome.switch )
game.results <- data.frame( strategy, outcome )
return( game.results )
}
x<-play_game()  # pander is for pretty printing
class(x)
x
library(dplyr)
library(pander)
#create a vector to create the number of doors, before we kept adding c(1,2,3)
build_doors <- function( n=5 ){ return( 1:n ) }
#Create a Game with with 5 doors and 2 cars
create_game <- function( )
{
a.game <- sample( x=rep(c("goat","car"), c(3,2)), size=5, replace=F )
return( a.game )
}
# Contestant makes initial pick
select_door <- function( )
{
doors <- build_doors()
a.pick <- sample( doors, size=1)
return( a.pick )
}
# Host open one goat door and one car door
open_goat_doors <- function( game, a.pick )
{   doors <- build_doors()
if( game[ a.pick ] == "car" )
{
goat.doors <- doors[ game == "goat" ]
opened.goat.door <- sample( goat.doors, size=1 )
car.door <- doors[game=="car" & doors != a.pick]
opened.doors <- c(car.door, opened.goat.door) #store answers as a vector
}
if( game[ a.pick ] == "goat" )
{
car.doors <- doors [game=="car"]
opened.car.door <- sample(car.doors, size=1)
goat.doors <-doors[game=="goat" & doors!=a.pick]
opened.goat.door <- sample(goat.doors, size=1)
opened.doors <- c(opened.car.door, opened.goat.door)
}
return( opened.doors )
}
# Scenario if contestant stays with a.pick or switches
change_door <- function( stay=T, opened.doors, a.pick )
{
doors <- build_doors()
if (stay==T)
{
final.pick <- a.pick
}
else
{
available.doors <- doors[ !(doors %in% opened.doors | doors == a.pick) ]
final.pick <- sample(available.doors, size = 1)
}
return( final.pick )  # number between 1 and 5
}
#If chosen door is car, WIN, if not, LOSE
determine_winner <- function( final.pick, game )
{
if(game[final.pick]=="car")
{
return( "WIN" )
}
else
{
return( "LOSE" )
}
}
this.game <- create_game()
my.initial.pick <- select_door()
opened.doors <- open_goat_doors( this.game, my.initial.pick )
# save results for both strategies for the game
my.final.pick.stay <- change_door( stay=T, opened.doors=opened.doors, a.pick=my.initial.pick )
my.final.pick.switch <- change_door( stay=F, opened.doors=opened.doors, a.pick=my.initial.pick )
game.outcome.stay <- determine_winner( final.pick=my.final.pick.stay, game=this.game )
game.outcome.switch <- determine_winner( final.pick=my.final.pick.switch, game=this.game )
play_game <- function( )
{
doors             <- build_doors()
new.game          <- create_game()
first.pick        <- select_door()
opened.door       <- open_goat_doors( new.game, first.pick )
final.pick.stay   <- change_door( stay=T, opened.door, first.pick )
final.pick.switch <- change_door( stay=F, opened.door, first.pick )
outcome.stay      <- determine_winner( final.pick.stay, new.game  )
outcome.switch    <- determine_winner( final.pick.switch, new.game )
strategy     <- c( "stay", "switch" )
outcome      <- c( outcome.stay, outcome.switch )
game.results <- data.frame( strategy, outcome )
return( game.results )
}
x<-play_game()  # pander is for pretty printing
class(x)
x
results.df <-NULL #collector, it needs to start empty
for (i in 1:10000) #iterator, how many times will we repeat this loop
{
game.outcome <- play_game()
results.df <- rbind(results.df,game.outcome) #binds results, add rows together
}
table(results.df)
( table( results.df ) / 10000 ) %>% round( 2 ) #divide each pieve by 10000, and round 2 decimal places
table( results.df ) %>%
prop.table( margin=1 ) %>%  # row proportions
round( 2 )
build_doors <- function( n=10 )
{
return( 1:n )
}
create_game <- function(num.goats=7, num.cars=3)
{
a.game <- sample( x=rep(c("goat","car"), c(num.goats,num.cars)), size=(num.goats+num.cars), replace=F )
return( a.game )
}
select_door <- function(game)
{
doors <- build_doors(n=length(game))
a.pick <- sample( doors, size=1)
return( a.pick )
}
open_goat_door <- function( game, a.pick )
{
doors <- build_doors(n=length(game))
doors.to.open <- doors[ ! ( game == "car" | doors == a.pick ) ]
opened.door <- sample(doors.to.open, size=1)
return( opened.door)
}
change_door <- function( stay=T, game, opened.door, a.pick )
{
doors <- build_doors(length(game))
if (stay==T)
{
final.pick <- a.pick
}
else
{
available.doors <- doors[ doors != opened.door & doors != a.pick ]
final.pick <- sample(available.doors, size = 1)
}
return( final.pick )  # number between 1 and 5
}
determine_winner <- function( final.pick, game )
{
if(game[final.pick]=="car")
{
return( "WIN" )
}
else
{
return( "LOSE" )
}
}
num.goats <- 7
num.cars <- 3
this.game <- create_game( num.goats, num.cars )
my.initial.pick <- select_door( game=this.game )
opened.door <- open_goat_door( this.game, my.initial.pick )
# save results for both strategies for the game
my.final.pick.stay <- change_door( stay=T, game=this.game,
opened.door=opened.door, a.pick=my.initial.pick )
my.final.pick.switch <- change_door( stay=F, game=this.game,
opened.door=opened.door, a.pick=my.initial.pick )
game.outcome.stay <- determine_winner( final.pick=my.final.pick.stay, game=this.game )
game.outcome.switch <- determine_winner( final.pick=my.final.pick.switch, game=this.game )
this.game
my.initial.pick
opened.door
my.final.pick.stay
game.outcome.stay
my.final.pick.switch
game.outcome.switch
play_game <- function(num.goats=7,num.cars=3 )
{
new.game          <- create_game(num.goats,num.cars)
first.pick        <- select_door(new.game)
opened.door       <- open_goat_door( new.game, first.pick )
final.pick.stay   <- change_door( stay=T, this.game, opened.door, first.pick )
final.pick.switch <- change_door( stay=F, this.game, opened.door, first.pick )
outcome.stay      <- determine_winner( final.pick.stay, new.game  )
outcome.switch    <- determine_winner( final.pick.switch, new.game )
strategy     <- c( "stay", "switch" )
outcome      <- c( outcome.stay, outcome.switch )
game.results <- data.frame( strategy, outcome )
return( game.results )
}
play_game() %>% pander()  # pander is for pretty printing
results.df.one <-NULL #scenario 1 with car and 9 goats
for (i in 1:10000) #iterator, how many times will we repeat this loop
{
game.outcome <- play_game(9,1)
results.df.one <- rbind(results.df.one,game.outcome) #binds results, add rows together
}
#Counts of Times Loss and Won with each strategy
table( results.df.one)
#Proportion of Times Loss and Won with each strategy
table( results.df.one ) %>%
prop.table( margin=1 ) %>%  # row proportions
round( 2 )
results.df.two <-NULL
for (i in 1:10000) #iterator, how many times will we repeat this loop
{
game.outcome <- play_game(8,2)
results.df.two <- rbind(results.df.two,game.outcome) #binds results, add rows together
}
table( results.df.two)
table( results.df.two ) %>%
prop.table( margin=1 ) %>%  # row proportions
round( 2 )
results.df.three <-NULL #scenario 1 with car and 9 goats
for (i in 1:10000) #iterator, how many times will we repeat this loop
{
game.outcome <- play_game(7,3)
results.df.three <- rbind(results.df.three,game.outcome) #binds results, add rows together
}
table( results.df.three)
table( results.df.three) %>%
prop.table( margin=1 ) %>%  # row proportions
round( 2 )
play_n_games <- function( n=100 )
{
library( dplyr )
results.list <- list()   # collector
loop.count <- 1
for( i in 1:n )  # iterator
{
game.outcome <- play_game()
results.list[[ loop.count ]] <- game.outcome
loop.count <- loop.count + 1
}
results.df <- dplyr::bind_rows( results.list )
table( results.df ) %>%
prop.table( margin=1 ) %>%  # row proportions
round( 2 ) %>%
print()
return( results.df )
}
play_n_games <- function( n=100 )
{
library( dplyr )
results.list <- list()   # collector
loop.count <- 1
for( i in 1:n )  # iterator
{
game.outcome <- play_game()
results.list[[ loop.count ]] <- game.outcome
loop.count <- loop.count + 1
}
results.df <- dplyr::bind_rows( results.list )
table( results.df ) %>%
prop.table( margin=1 ) %>%  # row proportions
round( 2 ) %>%
print()
return( results.df )
}
play_n_games()
play_n_games <- function( n=100 )
{
library( dplyr )
results.list <- list()   # collector
loop.count <- 1
for( i in 1:n )  # iterator
{
game.outcome <- play_game()
results.list[[ loop.count ]] <- game.outcome
loop.count <- loop.count + 1
}
results.df <- dplyr::bind_rows( results.list )
table( results.df ) %>%
prop.table( margin=1 ) %>%  # row proportions
round( 2 ) %>%
print()
return( results.df )
}
m<-play_n_games()
class(m)
m
play_n_games <- function( n=100 )
{
library( dplyr )
results.list <- list()   # collector
loop.count <- 1
for( i in 1:n )  # iterator
{
game.outcome <- play_game()
results.list[[ loop.count ]] <- game.outcome
loop.count <- loop.count + 1
}
results.df <- dplyr::bind_rows( results.list )
table( results.df ) %>%
prop.table( margin=1 ) %>%  # row proportions
round( 2 ) %>%
print()
return( results.df )
}
m<-play_n_games()
class(m)
mode(m)
m
play_n_games <- function( n=100 )
{
library( dplyr )
results.list <- list()   # collector
loop.count <- 1
for( i in 1:n )  # iterator
{
game.outcome <- play_game()
results.list[[ loop.count ]] <- game.outcome
loop.count <- loop.count + 1
}
results.df <- dplyr::bind_rows( results.list )
table( results.df ) %>%
prop.table( margin=1 ) %>%  # row proportions
round( 2 ) %>%
print()
return( results.df )
}
m<-play_n_games()
class(m)
mode(m)
library(dplyr)
library(pander)
#create a vector to create the number of doors, before we kept adding c(1,2,3)
build_doors <- function( n=5 ){ return( 1:n ) }
#Create a Game with with 5 doors and 2 cars
create_game <- function( )
{
a.game <- sample( x=rep(c("goat","car"), c(3,2)), size=5, replace=F )
return( a.game )
}
# Contestant makes initial pick
select_door <- function( )
{
doors <- build_doors()
a.pick <- sample( doors, size=1)
return( a.pick )
}
# Host open one goat door and one car door
open_goat_doors <- function( game, a.pick )
{   doors <- build_doors()
if( game[ a.pick ] == "car" )
{
goat.doors <- doors[ game == "goat" ]
opened.goat.door <- sample( goat.doors, size=1 )
car.door <- doors[game=="car" & doors != a.pick]
opened.doors <- c(car.door, opened.goat.door) #store answers as a vector
}
if( game[ a.pick ] == "goat" )
{
car.doors <- doors [game=="car"]
opened.car.door <- sample(car.doors, size=1)
goat.doors <-doors[game=="goat" & doors!=a.pick]
opened.goat.door <- sample(goat.doors, size=1)
opened.doors <- c(opened.car.door, opened.goat.door)
}
return( opened.doors )
}
# Scenario if contestant stays with a.pick or switches
change_door <- function( stay=T, opened.doors, a.pick )
{
doors <- build_doors()
if (stay==T)
{
final.pick <- a.pick
}
else
{
available.doors <- doors[ !(doors %in% opened.doors | doors == a.pick) ]
final.pick <- sample(available.doors, size = 1)
}
return( final.pick )  # number between 1 and 5
}
#If chosen door is car, WIN, if not, LOSE
determine_winner <- function( final.pick, game )
{
if(game[final.pick]=="car")
{
return( "WIN" )
}
else
{
return( "LOSE" )
}
}
this.game <- create_game()
my.initial.pick <- select_door()
opened.doors <- open_goat_doors( this.game, my.initial.pick )
# save results for both strategies for the game
my.final.pick.stay <- change_door( stay=T, opened.doors=opened.doors, a.pick=my.initial.pick )
my.final.pick.switch <- change_door( stay=F, opened.doors=opened.doors, a.pick=my.initial.pick )
game.outcome.stay <- determine_winner( final.pick=my.final.pick.stay, game=this.game )
game.outcome.switch <- determine_winner( final.pick=my.final.pick.switch, game=this.game )
play_game <- function( )
{
doors             <- build_doors()
new.game          <- create_game()
first.pick        <- select_door()
opened.door       <- open_goat_doors( new.game, first.pick )
final.pick.stay   <- change_door( stay=T, opened.door, first.pick )
final.pick.switch <- change_door( stay=F, opened.door, first.pick )
outcome.stay      <- determine_winner( final.pick.stay, new.game  )
outcome.switch    <- determine_winner( final.pick.switch, new.game )
strategy     <- c( "stay", "switch" )
outcome      <- c( outcome.stay, outcome.switch )
game.results <- data.frame( strategy, outcome )
return( game.results )
}
x<-play_game()  # pander is for pretty printing
class(x)
x
results.df <-NULL #collector, it needs to start empty
for (i in 1:10000) #iterator, how many times will we repeat this loop
{
game.outcome <- play_game()
results.df <- rbind(results.df,game.outcome) #binds results, add rows together
}
table(results.df)
( table( results.df ) / 10000 ) %>% round( 2 ) #divide each pieve by 10000, and round 2 decimal places
table( results.df ) %>%
prop.table( margin=1 ) %>%  # row proportions
round( 2 )
build_doors <- function( n=10 )
{
return( 1:n )
}
create_game <- function(num.goats=7, num.cars=3)
{
a.game <- sample( x=rep(c("goat","car"), c(num.goats,num.cars)), size=(num.goats+num.cars), replace=F )
return( a.game )
}
f <- create_game()
select_door <- function(game)
{
doors <- build_doors(n=length(game))
a.pick <- sample( doors, size=1)
return( a.pick )
}
d <- select_door(f)
build_doors <- function( n=10 )
{
return( 1:n )
}
create_game <- function(num.goats=7, num.cars=3)
{
a.game <- sample( x=rep(c("goat","car"), c(num.goats,num.cars)), size=(num.goats+num.cars), replace=F )
return( a.game )
}
f <- create_game()
select_door <- function(game)
{
doors <- build_doors(n=length(game))
a.pick <- sample( doors, size=1)
return( a.pick )
}
d <- select_door(f)
class(d)
d
devtools::document()
getwd()
